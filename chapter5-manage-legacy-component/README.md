# 5장 레거시 프로젝트를 위한 클래스형 컴포넌트

## 5.2 클래스형 컴포넌트 기본 사용법

### 5.2.1 setState는 상탯값을 병합

setState는 클래스형 컴포넌트에서 상탯값을 변경할 때 호출하는 메서드이다. setState 메서드로 입력된 객체는 기존의 상탯값과 병합된다. 리액트는 setState메서드가 호출되면 **해당 컴포넌트**를 다시 렌더링한다.


### 5.2.2 클래스필드를 이용해 이벤트 처리 메서드 작성

클래스 필드를 이용해서 이벤트 처리 메서드를 작성하면 함수에 바인딩을 적용하면서 렌더링 성능과 가독성이라는 두 마리 토끼를 잡을 수 있다. 기존에 많이 사용되던 방식은 렌더링 성능과 가독성 중에 하나를 선택해야 했다. 클래스필드는 아직 자바스크립트 표준이 아니지만 표준이 거의 확실시되고 있기 떄문에 바벨을 이용해서 안심하고 사용할 수 있다.

#### 함수 바인딩이 필요한 이유

클래스형 컴포넌트의 이벤트 처리 메서드는 자식 컴포넌트 또는 돔 요소의 속성값으로 전달할 수 있다. 이때 이벤트 처리 메서드와 this객체를 바인딩하지 않으면 메서드 호출 시 엉뚱한 객체를 가리킬 수 있다. 따라서 함수 바인ㄴ딩을 이용해서 this 객체를 고정할 필요가 있다.


#### 함수의 생성이 성능에 미치는 영향

render 메서드는 렌더링이 발생할 떄마다 호출된다. render메서드 내부에서 새로운 함수를 생성하면 성능에 부정적인 영향을 미친다. render 메서드에서 새로운 함수의 생성은 주로 두 가지 방식으로 발생한다.
<input onChange={e => onChange(e.currentTarget.value)}>
<input onChange={this.onChangeAge.bind(this)}>

화살표 함수 또는 일반 함수를 render메서드 내부에서 구현하면 render 메서드가 호출될 떄마다 새로운 함수가 생성된다. 함수의 bind 메서드를 호출하면 마찬가지로 새로운 함수가 생성된다.

일반적으로 .bind() 호출이 화살표 함수보다 성능에 더 큰 영향을 준다. 하지만 성능 개선이 많이 이루어진 최근의 브라우저에서는 함수 생성이 성능에 미치는 영향은 크지 않다. 브라우저의 성능이 개선된 덕분에 리액트 버전 16.8부터 도입된 훅은 렌더 함수 내부에서의 함수 생성을 적극적으로 활용한다. 